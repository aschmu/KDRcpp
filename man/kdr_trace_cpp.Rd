% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{kdr_trace_cpp}
\alias{kdr_trace_cpp}
\title{Kernel dimension reduction with rbf kernels}
\usage{
kdr_trace_cpp(X, Y, K, max_loop, sigmax0, sigmay0, eps, eta, anl,
  verbose = TRUE, tol = 1e-09)
}
\arguments{
\item{X}{an n x d matrix of inputs}

\item{Y}{an n x 1 matrix of outputs}

\item{max_loop}{the number of annealing steps}

\item{sigmax0}{the initial unannealed kernel for the \code{X} rbf kernel}

\item{sigmay0}{the initial unannealed kernel for the \code{Y} rbf kernel}

\item{eps}{a positive regularization parameter}

\item{eta}{a positive numeric, the upper bound of golden ratio search}

\item{anl}{a positive numeric, the annealing parameter}

\item{verbose}{a boolean for detailed output}

\item{tol}{a stopping tolerance for gradient descent}

\item{B}{a d x r matrix of initial effective directions estimate or an integer denoting the SDR subspace dimension}

\item{init_deriv}{a boolean indicating whether to initialize the SDR matrix estimate with the derivative at \code{B}}

\item{disp}{a boolean, whether to display optimization progress (not implemented)}
}
\value{
a d x r matrix with the estimated effective directions
}
\details{
For more details, see:Fukumizu, K. Francis R. Bach and M. Jordan. Kernel dimension reduction in regression.
The Annals of Statistics. 37(4), pp.1871-1905 (2009)
}
\examples{
\dontrun{
data(wine)
p <- 2target reduced dimension
l <- 3number of classes in the wine data
m <- ncol(wine) - l
X <- as.matrix(wine[, 1:m])
Y <- as.matrix(wine[, (m+1):(m+l)])
Xs <- scale(X)
sx <- estim_sigma_median(Xs)
sy <- estim_sigma_median(Y)

max_loop <- 50    number of iterations in kdr method
eps <- 0.0001   regularization parameter for matrix inversion	
eta <-10.0     range of the golden ratio search
anl	<- 4        maximum value for anealing
eta <- 10
verbose <- T    print the optimization process
disp <- 0
init_deriv <- F  1: initialization by derivative method. 0: random

Gaussian kernels are used.  Deviation parameter are set by the median of
mutual distances.   In the aneaning, sigma chages to 2*median to
0.5*median
sgx <- 0.5*sx
sgy <- sy  As Y is discrete, tuning is not necessary.

cputime <- system.time(B <- kdr_trace_cpp(X = Xs, Y = Y, K = p, max_loop = max_loop, sigmax0 = sx*sqrt(p/m),
                                         sigmay0 = sy, eps = eps, eta = eta, anl = anl, verbose = verbose,
                                         tol = 1e-9))

Z <- Xs\%*\%B

}
}

